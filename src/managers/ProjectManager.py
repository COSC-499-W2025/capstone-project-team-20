import sqlite3
import json
from typing import Any, Dict, Generator, Optional
from src.managers.StorageManager import StorageManager
from src.models.Project import Project


class ProjectManager(StorageManager):
    """Manages storage and retrieval of Project objects in the database.

    Checklist for adding a variable to this class:
        1. First ensure you've made the necessary changes for your new variable in Project.py
        2. Add variable to `create_table_query` method
        3. Add variable to `columns` method
        4. the display() method must be updated to reflect the addition of this variable
    """
    def __init__(self, db_path="projects.db") -> None:
        super().__init__(db_path)
        self._ensure_portfolio_details_column()

    def _ensure_portfolio_details_column(self) -> None:
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("PRAGMA table_info(projects)")
            existing = {row[1] for row in cursor.fetchall()}
            if "portfolio_details" not in existing:
                cursor.execute("ALTER TABLE projects ADD COLUMN portfolio_details TEXT")

    def _retrieve_id(self, cursor: sqlite3.Cursor, row: Dict[str, Any]) -> None:
        """
        Retrieves the autogenerated id from the cursor used on DB insert/replace.
        If an ID was not part of the upsert, the last inserted ID is used.
        """
        if "id" not in row or row["id"] is None:
            row["id"] = cursor.lastrowid

    @property
    def create_table_query(self) -> str:
        """
        Returns the SQL query to create the projects table.
        Includes resume_score and tech-profile fields.
        """
        return """CREATE TABLE IF NOT EXISTS projects (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        file_path TEXT NOT NULL,
        root_folder TEXT,
        num_files INTEGER,
        size_kb INTEGER,
        author_count INTEGER,
        authors TEXT,
        author_contributions TEXT,
        languages TEXT,
        language_share TEXT,
        frameworks TEXT,
        skills_used TEXT,
        dependencies_list TEXT,
        dependency_files_list TEXT,
        build_tools TEXT,
        individual_contributions TEXT,
        collaboration_status TEXT,
        categories TEXT,
        total_loc INTEGER,
        comment_ratio REAL,
        test_file_ratio REAL,
        avg_functions_per_file REAL,
        max_function_length INTEGER,
        testing_discipline_level TEXT,
        testing_discipline_score REAL,
        documentation_habits_level TEXT,
        documentation_habits_score REAL,
        modularity_level TEXT,
        modularity_score REAL,
        language_depth_level TEXT,
        language_depth_score REAL,
        has_dockerfile TEXT,
        has_database TEXT,
        has_frontend TEXT,
        has_backend TEXT,
        has_test_files TEXT,
        has_readme TEXT,
        readme_keywords TEXT,
        bullets TEXT,
        summary TEXT,
        portfolio_entry TEXT,
        portfolio_details TEXT,
        thumbnail TEXT,
        resume_score REAL,
        date_created TEXT,
        last_modified TEXT,
        last_accessed TEXT
        )"""

    @property
    def table_name(self) -> str:
        """Name of the table used for projects."""
        return "projects"

    @property
    def primary_key(self) -> str:
        """Primary key column for the projects table."""
        return "id"

    @property
    def columns(self) -> str:
        """
        Comma-separated list of column names for project storage.
        Must match create_table_query.
        """
        return (
            "id, name, file_path, root_folder, num_files, size_kb, author_count, "
            "authors, author_contributions, languages, language_share, frameworks, skills_used, "
            "dependencies_list, dependency_files_list, build_tools, "
            "individual_contributions, collaboration_status, categories, "
            "total_loc, comment_ratio, test_file_ratio, "
            "avg_functions_per_file, max_function_length, "
            "testing_discipline_level, testing_discipline_score, "
            "documentation_habits_level, documentation_habits_score, "
            "modularity_level, modularity_score, "
            "language_depth_level, language_depth_score, "
            "has_dockerfile, has_database, has_frontend, has_backend, "
            "has_test_files, has_readme, readme_keywords, "
            "bullets, summary, portfolio_entry, portfolio_details, thumbnail, resume_score, "
            "date_created, last_modified, last_accessed"
        )

    @property
    def columns_list(self) -> list[str]:
        return [c.strip() for c in self.columns.split(",")]

    def set(self, proj: Project) -> None:
        """
        Store a Project in the database.
        """
        project_dict = proj.to_dict()

        columns_to_set = self.columns_list
        if proj.id is None:
            columns_to_set = [c for c in columns_to_set if c != self.primary_key]

        with self._get_connection() as conn:
            cursor = conn.cursor()
            cols_str = ", ".join(columns_to_set)
            placeholders = ", ".join("?" for _ in columns_to_set)

            raw_values = [project_dict.get(col) for col in columns_to_set]
            values = []
            for v in raw_values:
                if isinstance(v, (list, dict)):
                    values.append(json.dumps(v))
                else:
                    values.append(v)

            query = f"INSERT OR REPLACE INTO {self.table_name} ({cols_str}) VALUES ({placeholders})"

            cursor.execute(query, values)

            if proj.id is None:
                proj.id = cursor.lastrowid


    def get(self, id: int) -> Optional[Project]:
        """Retrieve a Project from the database by its primary key."""
        file_dict = super().get(id)
        if file_dict is None:
            return None
        return Project.from_dict(file_dict)

    def get_by_name(self, name: str) -> Optional[Project]:
        """
        Retrieves a project by its unique name. This is essential for checking
        if a project already exists before deciding to update or insert.
        """
        with self._get_connection() as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            query = f"SELECT * FROM {self.table_name} WHERE name = ?"
            cursor.execute(query, (name,))
            result = cursor.fetchone()
            if result:
                return Project.from_dict(dict(result))
        return None

    def get_all(self) -> Generator[Project, None, None]:
        """Return a Generator that yields all stored projects."""
        for row in super().get_all():
            yield Project.from_dict(row)

    def get_all_as_dict(self) -> Generator[Dict[str, Any], None, None]:
        """Return a Generator that yields all stored projects as dicts."""
        for row in super().get_all():
            yield row
