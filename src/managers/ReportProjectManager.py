from typing import List, Optional, Dict, Any, Generator
from datetime import datetime
import sqlite3

from src.managers.StorageManager import StorageManager
from src.models.ReportProject import ReportProject


class ReportProjectManager(StorageManager):
    """Manages persistence of ReportProject snapshots"""
    # uses same db file as reports to allow for foreign key constraints
    def __init__(self, db_path: str = "reports.db") -> None:
        super().__init__(db_path)

    def _retrieve_id(self, cursor: sqlite3.Cursor, row: Dict[str, Any]) -> None:
        """
        Retrieves the autogenerated id from the cursor used on DB insert/replace.
        If an ID was not part of the upsert, the last inserted ID is used.
        """
        if "id" not in row or row["id"] is None:
            row["id"] = cursor.lastrowid
    
    @property
    def create_table_query(self) -> str:
        """
        SQL query to create the report_projects table. report_projects references the reports table.
        When a report is deleted, ON DELETE CASCADE ensures all associated report_projects are deleted too.
        """
        return """CREATE TABLE IF NOT EXISTS report_projects (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            report_id INTEGER NOT NULL,
            project_name TEXT NOT NULL,
            resume_score REAL DEFAULT 0.0,
            bullets TEXT,
            summary TEXT,
            languages TEXT,
            language_share TEXT,
            frameworks TEXT,
            date_created TEXT,
            last_modified TEXT,
            collaboration_status TEXT DEFAULT 'individual',
            FOREIGN KEY (report_id) REFERENCES reports(id) ON DELETE CASCADE
        )"""
    
    @property
    def table_name(self) -> str:
        return "report_projects"
    
    @property
    def primary_key(self) -> str:
        return "id"
    
    @property
    def columns(self) -> str:
        return (
            "id, report_id, project_name, resume_score, bullets, summary, "
            "languages, language_share, frameworks, date_created, "
            "last_modified, collaboration_status"
        )
    
    def set(self, row: Dict[str, Any]) -> None:
        """
        Store a ReportProject row.
        Expects a dict with all column values.
        """
        super().set(row)
    
    def set_from_report_project(self, report_id: int, report_project: ReportProject) -> None:
        """
        Store a ReportProject object for a given report.
        
        Args:
            report_id: id of the parent report
            report_project: ReportProject object to store
        """
        row = {
            "id": None, # AUTOINCREMENT field
            "report_id": report_id,
            "project_name": report_project.project_name,
            "resume_score": report_project.resume_score,
            "bullets": report_project.bullets,
            "summary": report_project.summary,
            "languages": report_project.languages,
            "language_share": report_project.language_share,
            "frameworks": report_project.frameworks,
            "date_created": report_project.date_created.isoformat() if report_project.date_created else None,
            "last_modified": report_project.last_modified.isoformat() if report_project.last_modified else None,
            "collaboration_status": report_project.collaboration_status,
        }
        self.set(row)
    
    def get(self, id: int) -> Optional[ReportProject]:
        """Retrieve a ReportProject by its primary key"""
        row_dict = super().get(id)
        if row_dict is None:
            return None
        return self._dict_to_report_project(row_dict)
    
    def get_all_for_report(self, report_id: int) -> List[ReportProject]:
        """
        Retrieve all ReportProjects for a given report.
        
        Args:
            report_id: ID of the parent report
            
        Returns:
            List of ReportProject objects
        """
        projects = []
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = f"SELECT {self.columns} FROM {self.table_name} WHERE report_id = ? ORDER BY id"
            cursor.execute(query, (report_id,))
            
            for row in cursor.fetchall():
                row_dict = dict(zip(self.columns_list, row))
                row_dict = self._deserialize_row(row_dict)
                projects.append(self._dict_to_report_project(row_dict))
        
        return projects
    
    def delete_by_name(self, report_id: int, project_name: str) -> bool:
        """
        Delete a ReportProject by project name within a specific report.
        
        Args:
            report_id: id of the parent report
            project_name: Name of the project to delete
            
        Returns:
            True if deleted successfully
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = f"DELETE FROM {self.table_name} WHERE report_id = ? AND project_name = ?"
            cursor.execute(query, (report_id, project_name))
            return cursor.rowcount > 0
    
    def delete_all_for_report(self, report_id: int) -> int:
        """
        Delete all ReportProjects for a given report.
        
        Args:
            report_id: id of the parent report
            
        Returns:
            Number of projects deleted
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = f"DELETE FROM {self.table_name} WHERE report_id = ?"
            cursor.execute(query, (report_id,))
            return cursor.rowcount
    
    def get_all(self) -> Generator[ReportProject, None, None]:
        """Yield all ReportProjects across all reports"""
        for row_dict in super().get_all():
            yield self._dict_to_report_project(row_dict)
    
    def _dict_to_report_project(self, row_dict: Dict[str, Any]) -> ReportProject:
        """Convert database row dict to ReportProject object"""
        # Convert datetime strings back to datetime objects
        date_created = None
        if row_dict.get("date_created"):
            try:
                date_created = datetime.fromisoformat(row_dict["date_created"])
            except (ValueError, TypeError):
                pass
        
        last_modified = None
        if row_dict.get("last_modified"):
            try:
                last_modified = datetime.fromisoformat(row_dict["last_modified"])
            except (ValueError, TypeError):
                pass
        
        return ReportProject(
            project_name=row_dict["project_name"],
            resume_score=row_dict.get("resume_score", 0.0),
            bullets=row_dict.get("bullets", []),
            summary=row_dict.get("summary", ""),
            languages=row_dict.get("languages", []),
            language_share=row_dict.get("language_share", {}),
            frameworks=row_dict.get("frameworks", []),
            date_created=date_created,
            last_modified=last_modified,
            collaboration_status=row_dict.get("collaboration_status", "individual"),
        )
