from typing import List, Literal, Optional, Dict, Any, Generator
from datetime import datetime
import sqlite3

from src.managers.StorageManager import StorageManager
from src.managers.ReportProjectManager import ReportProjectManager
from src.models.Report import Report
from src.models.ReportProject import ReportProject


class ReportManager(StorageManager):
    """ Manages persistence of Report objects."""
    
    def __init__(self, db_path: str = "reports.db") -> None:
        super().__init__(db_path)
        self.report_project_manager = ReportProjectManager()

    def _retrieve_id(self, cursor: sqlite3.Cursor, row: Dict[str, Any]) -> None:
        """
        Retrieves the autogenerated id from the cursor used on DB insert/replace.
        If an ID was not part of the upsert, the last inserted ID is used.
        """
        if "id" not in row or row["id"] is None:
            row["id"] = cursor.lastrowid
    
    @property
    def create_table_query(self) -> str:
        """SQL query to create the reports table"""
        return """CREATE TABLE IF NOT EXISTS reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            date_created TEXT NOT NULL,
            sort_by TEXT DEFAULT 'resume_score',
            notes TEXT
        )"""
    
    @property
    def table_name(self) -> str:
        return "reports"
    
    @property
    def primary_key(self) -> str:
        return "id"
    
    @property
    def columns(self) -> str:
        return "id, title, date_created, sort_by, notes"
    
    def create_report(self, report: Report) -> int:
        """
        Create a new report with its projects.
        
        Args:
            report: Report object to store
            
        Returns:
            id of created report
        """
        report_dict = report.to_dict()
        report_dict["id"] = None # AUTOINCREMENT field, returned after ReportManager.set()

        self.set(report_dict)
        id = report_dict["id"]

        for project in report.projects:
            self.report_project_manager.set_from_report_project(id, project)
        
        return id
    
    def get_report(self, id: int) -> Optional[Report]:
        """
        Retrieve a report with all its projects.
        
        Args:
            id: ID of report to retrieve
            
        Returns:
            Report object or None if not found
        """
        report_dict = super().get(id)
        if report_dict is None:
            return None

        projects = self.report_project_manager.get_all_for_report(id)

        return Report(
            id=report_dict["id"],
            title=report_dict["title"],
            date_created=datetime.fromisoformat(report_dict["date_created"]),
            sort_by=report_dict["sort_by"],
            projects=projects,
            notes=report_dict.get("notes")
        )
    
    def set_title(self, id: int, title: str) -> bool:
        """
        Update report title.
        
        Args:
            id: ID of report to update
            title: New title
            
        Returns:
            True if updated successfully
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = f"UPDATE {self.table_name} SET title = ? WHERE {self.primary_key} = ?"
            cursor.execute(query, (title, id))
            return cursor.rowcount > 0

    def set_notes(self, id: int, notes: Optional[str]) -> bool:
        """
        Update report notes.
        
        Args:
            id: ID of report to update
            notes: New notes (can be None to clear)
            
        Returns:
            True if updated successfully
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = f"UPDATE {self.table_name} SET notes = ? WHERE {self.primary_key} = ?"
            cursor.execute(query, (notes, id))
            return cursor.rowcount > 0

    def set_sort_by(self, id: int, sort_by: Literal["resume_score", "date_created", "last_modified"]) -> bool:
        """
        Update report sort order.
        
        Args:
            id: ID of report to update
            sort_by: New sort method
            
        Returns:
            True if updated successfully
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = f"UPDATE {self.table_name} SET sort_by = ? WHERE {self.primary_key} = ?"
            cursor.execute(query, (sort_by, id))
            return cursor.rowcount > 0
    
    def add_project_to_report(self, id: int, project: ReportProject) -> bool:
        """
        Add a project to an existing report.
        
        Args:
            id: ID of report to add project to
            project: ReportProject to add
            
        Returns:
            True if added successfully
        """
        try:
            self.report_project_manager.set_from_report_project(id, project)
            return True
        except Exception:
            return False
    
    def remove_project_from_report(self, id: int, project_name: str) -> bool:
        """
        Remove a project from a report by name.
        
        Args:
            id: ID of report
            project_name: Name of project to remove
            
        Returns:
            True if removed successfully
        """
        return self.report_project_manager.delete_by_name(id, project_name)
    
    def delete_report(self, id: int) -> bool:
        """
        Delete a Report and all its ReportProjects.
        
        Args:
            id: ID of report to delete
            
        Returns:
            True if deleted successfully
        """
        # ReportProjects deleted automatically via ON DELETE CASCADE
        return self.delete(id)
    
    def list_reports(self) -> List[Report]:
        """
        Retrieve all reports with their projects.
        
        Returns:
            List of Report objects
        """
        reports = []
        for row_dict in super().get_all():
            id = row_dict["id"]
            projects = self.report_project_manager.get_all_for_report(id)
            reports.append(Report(
                id=row_dict["id"],
                title=row_dict["title"],
                date_created=datetime.fromisoformat(row_dict["date_created"]),
                sort_by=row_dict["sort_by"],
                projects=projects,
                notes=row_dict.get("notes")
            ))
        
        return reports
    
    def list_reports_summary(self) -> List[Dict[str, Any]]:
        """
        Get lightweight report summaries without loading full projects.
        Useful for displaying report lists in menus.
        
        Returns:
            List of dicts with id, title, date_created, project_count
        """
        summaries = []
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = """
                SELECT 
                    r.id,
                    r.title,
                    r.date_created,
                    COUNT(rp.id) as project_count
                FROM reports r
                LEFT JOIN report_projects rp ON r.id = rp.report_id
                GROUP BY r.id
                ORDER BY r.date_created DESC
            """
            cursor.execute(query)
            
            for row in cursor.fetchall():
                summaries.append({
                    "id": row[0],
                    "title": row[1],
                    "date_created": row[2],
                    "project_count": row[3]
                })
        
        return summaries
    
    def update_report(self, report: Report) -> bool:
        """
        Persist edits to an existing report and all its ReportProjects.

        This updates the reports row (title/sort_by/notes) and replaces all
        report_projects rows for that report with the current in-memory list.
        """
        if report.id is None:
            return False

        # 1) Update report row
        self.set(report.to_dict())

        # 2) Replace all ReportProjects for this report
        self.report_project_manager.delete_all_for_report(report.id)
        for project in report.projects:
            self.report_project_manager.set_from_report_project(report.id, project)

        return True

    
    def get_all(self) -> Generator[Report, None, None]:
        """Yield all reports with their projects"""
        for report in self.list_reports():
            yield report
