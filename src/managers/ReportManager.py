from typing import List, Optional, Dict, Any, Generator
from datetime import datetime
import sqlite3

from src.managers.StorageManager import StorageManager
from src.managers.ReportProjectManager import ReportProjectManager
from src.models.Report import Report
from src.models.ReportProject import ReportProject


class ReportManager(StorageManager):
    """ Manages persistence of Report objects."""
    
    def __init__(self, db_path: str = "reports.db") -> None:
        super().__init__(db_path)
        self.report_project_manager = ReportProjectManager()

    def _retrieve_id(self, cursor: sqlite3.Cursor, row: Dict[str, Any]) -> None:
        """
        Retrieves the autogenerated id from the cursor used on DB insert/replace.
        If an ID was not part of the upsert, the last inserted ID is used.
        """
        if "id" not in row or row["id"] is None:
            row["id"] = cursor.lastrowid
    
    @property
    def create_table_query(self) -> str:
        """SQL query to create the reports table"""
        return """CREATE TABLE IF NOT EXISTS reports (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT NOT NULL,
            date_created TEXT NOT NULL,
            sort_by TEXT DEFAULT 'resume_score',
            notes TEXT
        )"""
    
    @property
    def table_name(self) -> str:
        return "reports"
    
    @property
    def primary_key(self) -> str:
        return "id"
    
    @property
    def columns(self) -> str:
        return "id, title, date_created, sort_by, notes"
    
    def create_report(self, report: Report) -> int:
        """
        Create a new report with its projects.
        
        Args:
            report: Report object to store
            
        Returns:
            id of created report
        """
        report_dict = report.to_dict()
        report_dict["id"] = None # AUTOINCREMENT field, returned after ReportManager.set()

        self.set(report_dict)
        id = report_dict["id"]

        for project in report.projects:
            self.report_project_manager.set_from_report_project(id, project)
        
        return id
    
    def get_report(self, id: int) -> Optional[Report]:
        """
        Retrieve a report with all its projects.
        
        Args:
            id: ID of report to retrieve
            
        Returns:
            Report object or None if not found
        """
        report_dict = super().get(id)
        if report_dict is None:
            return None

        projects = self.report_project_manager.get_all_for_report(id)

        return Report(
            id=report_dict["id"],
            title=report_dict["title"],
            date_created=datetime.fromisoformat(report_dict["date_created"]),
            sort_by=report_dict["sort_by"],
            projects=projects,
            notes=report_dict.get("notes")
        )
    
    def update_report_metadata(self, id: int, **kwargs) -> bool:
        """
        Update report metadata (title, notes, etc.).
        Does NOT update projects - use add_project/remove_project for that.
        
        Args:
            id: ID of report to update
            **kwargs: Fields to update (title, notes, sort_by, etc.)
            
        Returns:
            True if updated successfully
        """
        allowed_fields = {'title', 'sort_by', 'notes'}
        
        updates = {k: v for k, v in kwargs.items() if k in allowed_fields}
        if not updates:
            return False
        
        with self._get_connection() as conn:
            cursor = conn.cursor()
            set_clause = ", ".join(f"{k} = ?" for k in updates.keys())
            values = list(updates.values()) + [id]
            
            query = f"UPDATE {self.table_name} SET {set_clause} WHERE {self.primary_key} = ?"
            cursor.execute(query, values)
            return cursor.rowcount > 0
    
    def add_project_to_report(self, id: int, project: ReportProject) -> bool:
        """
        Add a project to an existing report.
        
        Args:
            id: ID of report to add project to
            project: ReportProject to add
            
        Returns:
            True if added successfully
        """
        try:
            self.report_project_manager.set_from_report_project(id, project)
            return True
        except Exception:
            return False
    
    def remove_project_from_report(self, id: int, project_name: str) -> bool:
        """
        Remove a project from a report by name.
        
        Args:
            id: ID of report
            project_name: Name of project to remove
            
        Returns:
            True if removed successfully
        """
        return self.report_project_manager.delete_by_name(id, project_name)
    
    def delete_report(self, id: int) -> bool:
        """
        Delete a Report and all its ReportProjects.
        
        Args:
            id: ID of report to delete
            
        Returns:
            True if deleted successfully
        """
        # ReportProjects deleted automatically via ON DELETE CASCADE
        return self.delete(id)
    
    def list_reports(self) -> List[Report]:
        """
        Retrieve all reports with their projects.
        
        Returns:
            List of Report objects
        """
        reports = []
        for row_dict in super().get_all():
            id = row_dict["id"]
            projects = self.report_project_manager.get_all_for_report(id)
            reports.append(Report(
                id=row_dict["id"],
                title=row_dict["title"],
                date_created=datetime.fromisoformat(row_dict["date_created"]),
                sort_by=row_dict["sort_by"],
                projects=projects,
                notes=row_dict.get("notes")
            ))
        
        return reports
    
    def list_reports_summary(self) -> List[Dict[str, Any]]:
        """
        Get lightweight report summaries without loading full projects.
        Useful for displaying report lists in menus.
        
        Returns:
            List of dicts with id, title, date_created, project_count
        """
        summaries = []
        with self._get_connection() as conn:
            cursor = conn.cursor()
            query = """
                SELECT 
                    r.id,
                    r.title,
                    r.date_created,
                    COUNT(rp.id) as project_count
                FROM reports r
                LEFT JOIN report_projects rp ON r.id = rp.report_id
                GROUP BY r.id
                ORDER BY r.date_created DESC
            """
            cursor.execute(query)
            
            for row in cursor.fetchall():
                summaries.append({
                    "id": row[0],
                    "title": row[1],
                    "date_created": row[2],
                    "project_count": row[3]
                })
        
        return summaries
    
    def get_all(self) -> Generator[Report, None, None]:
        """Yield all reports with their projects"""
        for report in self.list_reports():
            yield report
