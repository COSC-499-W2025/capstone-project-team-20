import sqlite3
from typing import Any, Dict, Generator, Optional
from src.StorageManager import StorageManager
from src.Project import Project

class ProjectManager(StorageManager):
    """Manages storage and retrieval of Project objects in the database."""
    def __init__(self, db_path="projects.db") -> None:
        super().__init__(db_path)

    def _retrieve_id(self, cursor: sqlite3.Cursor, row: Dict[str, Any]) -> None:
        """
        Retrieves the autogenerated id from the cursor used on DB insert/replace.
        If an ID was not part of the upsert, the last inserted ID is used.
        """
        if "id" not in row or row["id"] is None:
            row["id"] = cursor.lastrowid

    @property
    def create_table_query(self) -> str:
        """
        Returns the SQL query to create the projects table.
        A UNIQUE constraint is added to the 'name' column to prevent duplicate
        project entries and enable reliable upserts.
        """
        return """CREATE TABLE IF NOT EXISTS projects (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        file_path TEXT NOT NULL,
        root_folder TEXT,
        num_files INTEGER,
        size_kb INTEGER,
        author_count INTEGER,
        authors TEXT,
        languages TEXT,
        frameworks TEXT,
        skills_used TEXT,
        individual_contributions TEXT,
        collaboration_status TEXT,
        date_created TEXT,
        last_modified TEXT,
        last_accessed TEXT
        )"""

    @property
    def table_name(self) -> str:
        """Name of the table used for projects."""
        return "projects"

    @property
    def primary_key(self) -> str:
        """Primary key column for the projects table."""
        return "id"

    @property
    def columns(self) -> str:
        """Comma-separated list of column names for project storage."""
        return (
            "id, name, file_path, root_folder, num_files, size_kb, author_count, "
            "authors, languages, frameworks, skills_used, individual_contributions, "
            "collaboration_status, date_created, last_modified, last_accessed"
        )

    def set(self, proj: Project) -> None:
        """
        Store a Project in the database.

        Upserts (Update/Insert) a Project in the database using INSERT OR REPLACE.
        If a project with the same 'name' exists, it will be replaced.
        If the project object has an ID, that ID is used for the replacement.
        """
        project_dict = proj.to_dict()

        # We now use the full column list for the upsert operation.
        # This allows replacing a row while preserving its original ID if provided.
        columns_to_set = self.columns_list
        # If the project ID is None, we exclude it to allow auto-increment to work.
        if proj.id is None:
            columns_to_set = [c for c in columns_to_set if c != self.primary_key]

        with self._get_connection() as conn:
            cursor = conn.cursor()
            cols_str = ", ".join(columns_to_set)
            placeholders = ", ".join("?" for _ in columns_to_set)

            values = [project_dict.get(col) for col in columns_to_set]
            serialized_values = [
                json.dumps(v) if isinstance(v, (dict, list, bool)) else v
                for v in values
            ]

            # The "INSERT OR REPLACE" statement is the core of the upsert logic.
            # Ref: https://www.sqlite.org/lang_insert.html
            query = f"INSERT OR REPLACE INTO {self.table_name} ({cols_str}) VALUES ({placeholders})"
            cursor.execute(query, serialized_values)

            # Ensure the project object has the correct ID after the operation.
            self._retrieve_id(cursor, project_dict)
            proj.id = project_dict["id"]

    def get(self, id: int) -> Optional[Project]:
        """Retrieve a Project from the database by its primary key."""
        file_dict = super().get(id)
        if file_dict is None:
            return None
        return Project.from_dict(file_dict)

    def get_by_name(self, name: str) -> Optional[Project]:
        """
        Retrieves a project by its unique name. This is essential for checking
        if a project already exists before deciding to update or insert.
        """
        with self._get_connection() as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            query = f"SELECT * FROM {self.table_name} WHERE name = ?"
            cursor.execute(query, (name,))
            result = cursor.fetchone()
            if result:
                return Project.from_dict(dict(result))
        return None

    def get_all(self) -> Generator[Project, None, None]:
        """Return a Generator that yields all stored projects."""
        for row in super().get_all():
            yield Project.from_dict(row)

    def get_all_as_dict(self) -> Generator[Dict[str, Any], None, None]:
        """Return a Generator that yields all stored projects as dicts."""
        for row in super().get_all():
            yield row
